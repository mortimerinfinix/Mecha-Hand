<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Mecha Hand</title>

<style>
:root{
  --bg:#0f172a;
  --panel:#111827;
  --line:rgba(148,163,184,.22);
  --text:#e5e7eb;
  --muted:#a6b0bf;

  --blue:#3b82f6;
  --red:#ef4444;
  --green:#22c55e;
  --amber:#f59e0b;
  --pink:#fb7185;

  --shadow:0 0 0 1px rgba(148,163,184,.18),0 18px 60px rgba(0,0,0,.45);
  --shadowHover:0 0 0 1px rgba(148,163,184,.35),0 22px 70px rgba(0,0,0,.55);
  --radius:18px;
  --radius2:16px;
}

*{box-sizing:border-box}
html,body{height:100%}

body{
  margin:0;
  background:radial-gradient(1100px 650px at 20% 0%,#16224a 0%,var(--bg) 55%) fixed;
  color:var(--text);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  -webkit-tap-highlight-color:transparent;
}

.app{
  min-height:100dvh;
  display:flex;
  flex-direction:column;
  gap:12px;
  padding:14px;
}

h1{margin:0 0 2px}
.muted{color:var(--muted); margin:0 0 10px; line-height:1.35}

.row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}

.btn{
  padding:12px 16px;
  border-radius:16px;
  border:1px solid var(--line);
  background:rgba(255,255,255,.06);
  color:var(--text);
  cursor:pointer;
  transition:transform .08s ease, box-shadow .2s ease, border-color .2s ease;
}
.btn:hover{box-shadow:var(--shadowHover)}
.btn:active{transform:scale(.97)}
.btn.primary{background:linear-gradient(#3b82f6,#2563eb);border-color:#3b82f6}
.btn.danger{background:linear-gradient(#ef4444,#dc2626);border-color:#ef4444}
.btn.ghost{background:rgba(255,255,255,.04)}
.btn[disabled]{opacity:.5; cursor:not-allowed; box-shadow:none}

.panel{
  background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.03));
  border:1px solid var(--line);
  border-radius:var(--radius);
  padding:12px;
  box-shadow:var(--shadow);
}

/* SIDE-BY-SIDE */
.board{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:12px;
}
.board .panel{min-height:220px}

.sideTitle{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  margin-bottom:10px;
}

.bars{display:flex;flex-direction:column;gap:10px}
.bar{
  border:1px solid var(--line);
  border-radius:14px;
  padding:8px;
  background:rgba(255,255,255,.04);
}
.barTop{
  display:flex;
  justify-content:space-between;
  font-size:12px;
  color:var(--muted);
  margin-bottom:7px;
}
.track{
  height:10px;
  background:rgba(148,163,184,.18);
  border-radius:999px;
  overflow:hidden;
}
.fill{height:100%}

/* Hand */
.handPanel{
  flex:1 1 auto;
  display:flex;
  flex-direction:column;
  min-height:0;
}
.handHeader{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  margin-bottom:10px;
}
.pill{
  font-size:12px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid var(--line);
  background:rgba(255,255,255,.04);
  color:var(--muted);
}
.pill strong{color:var(--text)}
.pill .ok{color:#bbf7d0}
.pill .warn{color:#fde68a}
.pill .bad{color:#fecaca}

/* Popup area inside hand panel */
.popup{
  display:none;
  border:1px solid rgba(148,163,184,.22);
  background:linear-gradient(180deg,rgba(2,6,23,.55),rgba(2,6,23,.35));
  border-radius:16px;
  padding:12px;
  margin-bottom:10px;
}
.popupTitle{ font-weight:950; font-size:14px; }
.popupBody{ margin-top:6px; color:var(--text); line-height:1.35; }
.popupSub{ margin-top:6px; color:var(--muted); font-size:13px; line-height:1.35; }
.popupActions{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin-top:10px;
}

.hand{
  flex:1 1 auto;
  overflow:auto;
  min-height:0;
  padding-right:2px;
}
.card{
  margin:8px 0;
  padding:12px;
  border-radius:var(--radius2);
  border:1px solid var(--line);
  background:rgba(255,255,255,.05);
  cursor:pointer;
  transition:transform .08s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease, opacity .2s ease, filter .2s ease;
}
.card:hover{box-shadow:var(--shadowHover); background:rgba(255,255,255,.07)}
.card:active{transform:scale(.985)}
.card b{font-weight:950}
.desc{font-size:13px;color:var(--muted);margin-top:6px;line-height:1.35}
.meta{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap}
.tag{
  font-size:12px;
  padding:4px 10px;
  border-radius:999px;
  border:1px solid var(--line);
  background:rgba(255,255,255,.04);
  color:var(--muted);
}

.card.selected{
  border-color:rgba(59,130,246,.55);
  box-shadow:0 0 0 1px rgba(59,130,246,.35), 0 18px 60px rgba(59,130,246,.10);
}
.card.disabled{
  opacity:.45;
  filter:saturate(.75);
  cursor:not-allowed;
}

/* Error box */
.errorBox{
  margin-top:10px;
  border:1px solid rgba(239,68,68,.45);
  background:rgba(239,68,68,.08);
  border-radius:16px;
  padding:12px;
  color:#fecaca;
  display:none;
  white-space:pre-wrap;
  font-size:12px;
}
</style>
</head>

<body>
<div class="app">
  <div>
    <h1>Mecha Hand</h1>
    <div class="muted">Select cards until you run out of energy ‚Äî then Play Selected.</div>
    <div class="row">
      <button class="btn primary" id="newBtn">New Game</button>
      <button class="btn" id="rulesBtn">Rules</button>
    </div>
  </div>

  <div class="board">
    <div class="panel" id="playerPanel"></div>
    <div class="panel" id="enemyPanel"></div>
  </div>

  <div class="panel handPanel">
    <div class="handHeader">
      <b>üÉè Your Hand</b>
      <span class="pill" id="handPill"></span>
    </div>

    <div class="popup" id="popup">
      <div class="popupTitle" id="popupTitle"></div>
      <div class="popupBody" id="popupBody"></div>
      <div class="popupSub" id="popupSub"></div>
      <div class="popupActions" id="popupActions"></div>
    </div>

    <div class="hand" id="hand"></div>

    <div class="errorBox" id="errorBox"></div>
  </div>
</div>

<script>
(() => {
  const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));
  const shuffle=a=>{for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}};
  function haptic(kind="tap"){
    if(!("vibrate" in navigator)) return;
    try{
      if(kind==="tap") navigator.vibrate(12);
      else if(kind==="ok") navigator.vibrate([10,18,10]);
      else if(kind==="warn") navigator.vibrate([35,25,35]);
    }catch(_){}
  }
  function esc(s){return String(s).replace(/[&<>"']/g,m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]))}
  function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

  const playerPanel = document.getElementById("playerPanel");
  const enemyPanel  = document.getElementById("enemyPanel");
  const handEl      = document.getElementById("hand");
  const handPill    = document.getElementById("handPill");

  const popup        = document.getElementById("popup");
  const popupTitle   = document.getElementById("popupTitle");
  const popupBody    = document.getElementById("popupBody");
  const popupSub     = document.getElementById("popupSub");
  const popupActions = document.getElementById("popupActions");

  const errorBox = document.getElementById("errorBox");
  function showError(err){
    errorBox.style.display="block";
    errorBox.textContent =
      "‚ö†Ô∏è A script error stopped the game from drawing cards.\n\n" +
      (err && err.stack ? err.stack : String(err));
  }

  // Catch unexpected errors so you never get a blank hand again
  window.addEventListener("error", (e)=>{ showError(e.error || e.message); });
  window.addEventListener("unhandledrejection", (e)=>{ showError(e.reason || e); });

  function showPopup({title="", body="", sub="", actionsHTML=""}){
    popupTitle.textContent = title;
    popupBody.innerHTML = body;
    popupSub.textContent = sub;
    popupActions.innerHTML = actionsHTML;
    popup.style.display = "block";
  }
  function hidePopup(){
    popup.style.display = "none";
    popupTitle.textContent = "";
    popupBody.innerHTML = "";
    popupSub.textContent = "";
    popupActions.innerHTML = "";
  }

  /* ====== Cards ====== */
  const CARDS = [
    card("Rail Shot","Deal 7 damage. +2 Heat.","‚öîÔ∏è Attack ‚Ä¢ ‚ö°2 ‚Ä¢ üî•+2",{cost:2, dmg:7, heat:+2}),
    card("Burst Cannons","Deal 5 damage. If enemy has Armor, +3 damage. +1 Heat.","‚öîÔ∏è Attack ‚Ä¢ ‚ö°2 ‚Ä¢ üî•+1",{cost:2, dmg:5, bonusIfArmor:3, heat:+1}),
    card("Vibro Blade","Deal 4 damage. If enemy is Overheated, +4 damage.","‚öîÔ∏è Attack ‚Ä¢ ‚ö°1",{cost:1, dmg:4, bonusIfOverheat:4}),
    card("Guard Plates","Gain 6 Armor. -1 Heat.","üõ°Ô∏è Defense ‚Ä¢ ‚ö°2 ‚Ä¢ üî•-1",{cost:2, armor:+6, heat:-1}),
    card("Smoke Screen","Gain 4 Armor. Enemy next damage -3.","üõ°Ô∏è Defense ‚Ä¢ ‚ö°2",{cost:2, armor:+4, damp:3}),
    card("Coolant Flush","Reduce Heat by 4. Gain 1 Energy.","üß† Utility ‚Ä¢ ‚ö°0 ‚Ä¢ üî•-4",{cost:0, heat:-4, energy:+1}),
    card("Overclock","Gain 3 Energy. +3 Heat.","üß† Utility ‚Ä¢ ‚ö°0 ‚Ä¢ üî•+3",{cost:0, energy:+3, heat:+3}),
    card("Repair Drone","Heal 5. If Heat ‚â§ 2, heal +3.","üß† Utility ‚Ä¢ ‚ö°2",{cost:2, heal:5, bonusHealIfCool:3}),
    card("Plasma Lance","Deal 9 damage. +4 Heat.","‚öîÔ∏è Attack ‚Ä¢ ‚ö°3 ‚Ä¢ üî•+4",{cost:3, dmg:9, heat:+4}),
  ];
  function card(name, desc, meta, eff){ return { name, desc, meta, eff }; }
  function cardType(c){
    const e = c.eff || {};
    if(typeof e.dmg==="number") return "attack";
    if(typeof e.armor==="number" || typeof e.damp==="number") return "defense";
    return "utility";
  }

  /* ====== Enemy plan labels (no "intent" word in UI) ====== */
  const ENEMY_PLAN = {
    ALL_OUT_ASSAULT: "All-Out Assault",
    FORTIFY_POSITION: "Fortify Position",
    MEASURED_ADVANCE: "Measured Advance",
    SYSTEMS_CALIBRATION: "Systems Calibration",
    OVERCHARGE_STRIKE: "Overcharge Strike",
    EMERGENCY_RECOVERY: "Emergency Recovery",
  };

  function mech(){ return { hp:30, armor:0, energy:3, heat:0, overheated:false, meltdown:false }; }

  let S=null;

  function setOverheatFlags(){
    S.player.overheated = S.player.heat >= 8;
    S.enemy.overheated  = S.enemy.heat  >= 8;
    S.player.meltdown   = S.player.heat >= 10;
    S.enemy.meltdown    = S.enemy.heat  >= 10;
  }

  function buildDeck(){
    const picks=[];
    while(picks.length<24){
      const base = CARDS[picks.length % CARDS.length];
      picks.push({ ...base, _id: base.name+"-"+Math.random().toString(16).slice(2,6) });
    }
    S.deck = picks;
    shuffle(S.deck);
    S.discard = [];
  }

  function draw(n){
    while(n-- > 0){
      if(S.deck.length===0){
        if(S.discard.length===0) break;
        S.deck = S.discard.splice(0);
        shuffle(S.deck);
      }
      S.hand.push(S.deck.shift());
    }
  }

  function computeEnemyPlan(){
    const e=S.enemy, p=S.player;
    if(e.hp<=10) return "EMERGENCY_RECOVERY";
    if(e.heat>=8) return "SYSTEMS_CALIBRATION";
    if(p.hp<=10) return "OVERCHARGE_STRIKE";
    if(e.armor<=2 && e.hp>=18) return "ALL_OUT_ASSAULT";
    if(e.armor>=6 || e.hp<=14) return "FORTIFY_POSITION";
    return "MEASURED_ADVANCE";
  }

  function startRound(){
    S.hand=[];
    S.selected=[];
    S.dampToPlayer=0;
    S.dampToEnemy=0;

    const pPenalty = S.player.meltdown ? 1 : 0;
    const ePenalty = S.enemy.meltdown  ? 1 : 0;

    S.player.energy = clamp(S.player.energy + 2 - pPenalty, 0, 6);
    S.player.heat   = clamp(S.player.heat - 1, 0, 99);

    S.enemy.energy  = clamp(S.enemy.energy + 2 - ePenalty, 0, 6);
    S.enemy.heat    = clamp(S.enemy.heat - 1, 0, 99);

    draw(5);

    S.enemyPlanId = computeEnemyPlan();
    S.enemyPlanLabel = ENEMY_PLAN[S.enemyPlanId];

    setOverheatFlags();
  }

  function selectedCost(){
    return S.selected.map(i=>S.hand[i]).filter(Boolean).reduce((sum,c)=>sum+(c.eff.cost||0),0);
  }
  function remainingEnergy(){
    return S.player.energy - selectedCost();
  }
  function wouldExceedEnergy(idx){
    if(S.selected.includes(idx)) return false;
    const c=S.hand[idx];
    if(!c) return true;
    return (selectedCost() + (c.eff.cost||0)) > S.player.energy;
  }

  function applyDamage(target, dmg){
    const armorHit = Math.min(target.armor, dmg);
    target.armor -= armorHit;
    dmg -= armorHit;
    const hpHit = Math.max(0, dmg);
    if(hpHit>0) target.hp = clamp(target.hp - hpHit, 0, 30);
    return { armorHit, hpHit };
  }

  function playCard(who, c){
    const P = (who==="player") ? S.player : S.enemy;
    const E = (who==="player") ? S.enemy  : S.player;
    const eff = c.eff;

    const cost = eff.cost||0;
    if(P.energy < cost){
      return `${who==="player"?"You":"Enemy"} tried ${c.name}, but lacked energy.`;
    }
    P.energy -= cost;

    if(eff.energy) P.energy = clamp(P.energy + eff.energy, 0, 9);
    if(eff.heat)   P.heat   = clamp(P.heat + eff.heat, 0, 99);
    if(eff.armor)  P.armor  = clamp(P.armor + eff.armor, 0, 99);

    if(eff.damp){
      if(who==="player") S.dampToEnemy = eff.damp;
      else S.dampToPlayer = eff.damp;
      return `${who==="player"?"You":"Enemy"} used ${c.name} ‚Äî next incoming damage is reduced.`;
    }

    if(eff.heal){
      let heal = eff.heal;
      if(eff.bonusHealIfCool && P.heat<=2) heal += eff.bonusHealIfCool;
      const before=P.hp;
      P.hp = clamp(P.hp + heal, 0, 30);
      const gained=P.hp-before;
      return `${who==="player"?"You":"Enemy"} used ${c.name} (+${gained} HP).`;
    }

    if(eff.dmg){
      let dmg = eff.dmg;
      if(eff.bonusIfArmor && E.armor>0) dmg += eff.bonusIfArmor;

      setOverheatFlags();
      if(eff.bonusIfOverheat && E.overheated) dmg += eff.bonusIfOverheat;
      if(P.overheated) dmg = Math.max(0, dmg - 2);

      if(who==="player" && S.dampToEnemy>0){ dmg=Math.max(0,dmg-S.dampToEnemy); S.dampToEnemy=0; }
      if(who==="enemy" && S.dampToPlayer>0){ dmg=Math.max(0,dmg-S.dampToPlayer); S.dampToPlayer=0; }

      const hit=applyDamage(E, dmg);
      return `${who==="player"?"You":"Enemy"} used ${c.name} (‚àí${hit.armorHit} armor, ‚àí${hit.hpHit} HP).`;
    }

    return `${who==="player"?"You":"Enemy"} used ${c.name}.`;
  }

  function applyCombo(first, second){
    const t1 = cardType(first);
    const t2 = cardType(second);
    const comboNotes = [];
    const secondEff = deepClone(second.eff);

    if(t1==="attack" && t2==="attack"){
      if(typeof secondEff.dmg==="number") secondEff.dmg += 2;
      secondEff.heat = (secondEff.heat||0) + 2;
      comboNotes.push("Combo: Attack‚ÜíAttack (+2 dmg on next, +2 heat).");
    }
    if(t1==="defense" && t2==="attack"){
      if(typeof secondEff.dmg==="number") secondEff.dmg += 3;
      comboNotes.push("Combo: Defense‚ÜíAttack (+3 dmg).");
    }
    if(t1==="utility" && t2==="attack"){
      secondEff.cost = Math.max(0, (secondEff.cost||0) - 1);
      comboNotes.push("Combo: Utility‚ÜíAttack (attack costs -1 energy).");
    }
    if(t1==="attack" && t2==="defense"){
      if(typeof secondEff.armor==="number") secondEff.armor += 2;
      comboNotes.push("Combo: Attack‚ÜíDefense (+2 armor).");
    }
    if(t1==="utility" && t2==="defense"){
      secondEff.heat = (secondEff.heat||0) - 2;
      comboNotes.push("Combo: Utility‚ÜíDefense (-2 extra heat).");
    }

    return { secondCardMod: { ...second, eff: secondEff }, comboNotes };
  }

  function enemyTurn(){
    const temp=[];
    for(let i=0;i<5;i++){
      if(S.deck.length===0){
        if(S.discard.length===0) break;
        S.deck = S.discard.splice(0);
        shuffle(S.deck);
      }
      temp.push(S.deck.shift());
    }

    function score(c){
      const eff=c.eff;
      let s=0;
      if(eff.heal)  s += (S.enemy.hp<=12? 14:6) + eff.heal;
      if(eff.armor) s += 4 + eff.armor*0.7;
      if(eff.dmg)   s += 7 + eff.dmg*0.95;
      if(eff.energy) s += eff.energy*1.2;
      if(eff.heat)  s -= Math.max(0, (S.enemy.heat+eff.heat)-7)*1.2;
      return s;
    }

    const typed = temp.map(c=>({ c, t: cardType(c), sc: score(c) }));

    function best(pred){
      const candidates = typed.filter(pred).sort((a,b)=>b.sc-a.sc);
      return candidates.length ? candidates[0].c : null;
    }
    function removeFromPool(card){
      const idx = typed.findIndex(x=>x.c===card);
      if(idx>=0) typed.splice(idx,1);
    }

    const plan = S.enemyPlanId;
    let first=null, second=null;

    if(plan==="ALL_OUT_ASSAULT"){
      first = best(x=>x.t==="attack") || best(()=>true);
      if(first) removeFromPool(first);
      second = best(x=>x.t==="attack") || best(x=>x.t==="utility") || best(()=>true);
    }else if(plan==="FORTIFY_POSITION"){
      first = best(x=>x.t==="defense") || best(x=>x.t==="utility") || best(()=>true);
      if(first) removeFromPool(first);
      second = best(x=>x.t==="attack") || best(x=>x.t==="defense") || best(()=>true);
    }else if(plan==="MEASURED_ADVANCE"){
      first = best(x=>x.t==="attack") || best(()=>true);
      if(first) removeFromPool(first);
      second = best(x=>x.t!=="attack") || best(()=>true);
    }else if(plan==="SYSTEMS_CALIBRATION"){
      first = best(x=>x.t==="utility") || best(x=>x.t==="defense") || best(()=>true);
      if(first) removeFromPool(first);
      second = best(x=>x.t==="utility") || best(x=>x.t==="defense") || best(()=>true);
    }else if(plan==="OVERCHARGE_STRIKE"){
      first = best(x=>x.t==="attack") || best(()=>true);
      if(first) removeFromPool(first);
      second = best(x=>x.t==="attack") || best(x=>x.t==="utility") || best(()=>true);
    }else if(plan==="EMERGENCY_RECOVERY"){
      first = best(x=>x.c.eff.heal) || best(x=>x.t==="defense") || best(x=>x.t==="utility") || best(()=>true);
      if(first) removeFromPool(first);
      second = best(x=>x.c.eff.heal) || best(x=>x.t==="defense") || best(x=>x.t==="utility") || best(()=>true);
    }else{
      first = best(()=>true);
      if(first) removeFromPool(first);
      second = best(()=>true);
    }

    if(!first && temp.length) first=temp[0];
    if(!second){
      const remaining = temp.filter(c=>c!==first);
      second = remaining.length ? remaining[0] : first;
    }

    const chosen = [first, second].filter(Boolean);
    const chosenSet = new Set(chosen);
    temp.forEach(c=>{ if(!chosenSet.has(c)) S.discard.push(c); });

    const combo = applyCombo(chosen[0], chosen[1]);
    const lines=[];
    lines.push(playCard("enemy", chosen[0]));
    lines.push(playCard("enemy", combo.secondCardMod));

    S.discard.push(chosen[0], chosen[1]);

    return {
      chosenNames: chosen.map(c=>esc(c.name)).join(" + "),
      comboNotes: combo.comboNotes,
      lines
    };
  }

  function playSelected(){
    if(S.enemy.hp<=0 || S.player.hp<=0) return;

    if(S.selected.length===0){
      haptic("warn");
      showPopup({
        title:"No cards selected",
        body:"Select at least 1 card before playing.",
        sub:"You can play as many as your energy allows.",
        actionsHTML:`<button class="btn primary" onclick="hidePopup()">OK</button>`
      });
      return;
    }
    haptic("ok");

    const chosen = S.selected.map(i=>S.hand[i]).filter(Boolean);
    const unplayed = S.hand.filter((_,i)=>!S.selected.includes(i));

    const pLines=[];
    const comboNotesAll=[];

    for(let i=0;i<chosen.length;i++){
      if(i===0){
        pLines.push(playCard("player", chosen[i]));
      }else{
        const combo = applyCombo(chosen[i-1], chosen[i]);
        comboNotesAll.push(...combo.comboNotes);
        pLines.push(playCard("player", combo.secondCardMod));
      }
    }

    chosen.forEach(c=>S.discard.push(c));
    unplayed.forEach(c=>S.discard.push(c));

    const enemyResult = enemyTurn();

    setOverheatFlags();
    const extra=[];
    if(S.player.meltdown){ S.player.hp=clamp(S.player.hp-3,0,30); extra.push("‚ö†Ô∏è Meltdown: your reactor spikes (‚àí3 HP)."); }
    if(S.enemy.meltdown){ S.enemy.hp=clamp(S.enemy.hp-3,0,30); extra.push("‚ö†Ô∏è Enemy meltdown (‚àí3 HP)."); }

    const playedNames = chosen.map(c=>esc(c.name)).join(" ‚Üí ");
    const comboText = comboNotesAll.length
      ? `<br><br><b>Combos triggered:</b><br>${[...new Set(comboNotesAll)].map(esc).join("<br>")}`
      : `<br><br><b>No combos</b> (try mixing types in order).`;

    const enemyComboText = enemyResult.comboNotes.length
      ? `<br><br><b>Enemy combo:</b><br>${enemyResult.comboNotes.map(esc).join("<br>")}`
      : "";

    // BEFORE starting a new round, check win/lose
    const isWin  = S.enemy.hp<=0;
    const isLose = S.player.hp<=0;
    render(); // update bars immediately

    showPopup({
      title: isWin ? "Victory" : (isLose ? "Defeat" : "Round resolved"),
      body:
        `<b>You played:</b> ${playedNames}<br>`+
        `${pLines.map(esc).join("<br>")}`+
        comboText+
        `<br><br><b>Enemy plan:</b> ${esc(S.enemyPlanLabel)}<br>`+
        `<b>Enemy played:</b> ${enemyResult.chosenNames}<br>`+
        `${enemyResult.lines.map(esc).join("<br>")}`+
        enemyComboText+
        (extra.length?`<br><br><span style="color:var(--pink)">${extra.map(esc).join("<br>")}</span>`:""),
      sub: isWin ? "Start the next fight?" : (isLose ? "Start a new game?" : "Continue to next round."),
      actionsHTML: isWin
        ? `<button class="btn primary" onclick="nextFight()">OK</button>`
        : (isLose
            ? `<button class="btn primary" onclick="newGame()">New Game</button>`
            : `<button class="btn primary" onclick="nextRound()">OK</button>`)
    });

    // Clear selection and hand now; nextRound/nextFight will rebuild
    S.hand=[];
    S.selected=[];
  }

  function nextRound(){
    hidePopup();
    S.round++;
    startRound();
    render();
  }

  function nextFight(){
    hidePopup();
    // For now: just refresh enemy and continue (keeps your mechanics; you can expand later)
    S.enemy = mech();
    startRound();
    render();
  }

  function barHtml(label, value, max, color){
    const pct = max===0 ? 0 : (value/max)*100;
    return `
      <div class="bar">
        <div class="barTop"><span>${label}</span><span>${value} / ${max}</span></div>
        <div class="track"><div class="fill" style="width:${pct}%;background:${color}"></div></div>
      </div>
    `;
  }

  function renderSide(title, mech, planLabel, showPlan){
    const hpColor = (mech.hp<=10) ? "var(--red)" : (mech.hp<=18 ? "var(--amber)" : "var(--green)");
    const heatColor = (mech.heat>=10) ? "var(--red)" : (mech.heat>=8 ? "var(--amber)" : "var(--pink)");
    const heatMsg =
      mech.heat>=10 ? "‚ö†Ô∏è Reactor critical." :
      mech.heat>=8  ? "‚ö†Ô∏è Overheated." :
                      "‚úÖ Reactor stable.";

    return `
      <div class="sideTitle">
        <b>${esc(title)}</b>
      </div>
      <div class="bars">
        ${barHtml("HP", mech.hp, 30, hpColor)}
        ${barHtml("Armor", mech.armor, 20, "var(--blue)")}
        ${barHtml("Energy", mech.energy, 6, "var(--amber)")}
        ${barHtml("Heat", mech.heat, 10, heatColor)}
      </div>
      <div class="muted" style="margin-top:10px">${heatMsg}</div>
      ${showPlan ? `<div class="muted" style="margin-top:8px"><b>Plan:</b> ${esc(planLabel)}</div>` : ``}
    `;
  }

  function render(){
    try{
      setOverheatFlags();

      playerPanel.innerHTML = renderSide("üßë Player", S.player, "", false);
      enemyPanel.innerHTML  = renderSide("ü§ñ Enemy",  S.enemy,  S.enemyPlanLabel, true);

      const cost = selectedCost();
      const rem = remainingEnergy();
      const remClass = rem >= 2 ? "ok" : (rem >= 0 ? "warn" : "bad");

      handPill.innerHTML =
        `<strong>Energy</strong>: ${S.player.energy} ‚Ä¢ <strong>Selected</strong>: ${cost} ‚Ä¢ <strong class="${remClass}">Rem.</strong>: ${rem}`;

      // If hand is empty for any reason, auto-fix it
      if(!S.hand || S.hand.length===0){
        S.hand=[];
        draw(5);
      }

      const selectedNames = S.selected.map(i=>S.hand[i]).filter(Boolean).map(c=>c.name);
      const chain = selectedNames.length ? selectedNames.map(esc).join(" ‚Üí ") : "None";

      showPopup({
        title:"Your selection",
        body:`<b>Chain:</b> ${chain}<br><b>Cost:</b> ${cost} / ${S.player.energy}`,
        sub:"Tap selected cards again to unselect. When ready, play your chain.",
        actionsHTML:`
          <button class="btn ghost" onclick="clearSelection()">Clear</button>
          <button class="btn primary" onclick="playSelected()">Play Selected</button>
        `
      });

      handEl.innerHTML = S.hand.map((c,idx)=>{
        const selected = S.selected.includes(idx);
        const disabled = !selected && wouldExceedEnergy(idx);
        const t = cardType(c);
        const tLabel = t==="attack" ? "Attack" : (t==="defense" ? "Defense" : "Utility");

        return `
          <div class="card ${selected ? "selected" : ""} ${disabled ? "disabled" : ""}"
               onclick="selectCard(${idx})"
               aria-disabled="${disabled ? "true" : "false"}">
            <b>${selected ? "‚úÖ " : ""}${esc(c.name)}</b>
            <div class="desc">${esc(c.desc)}</div>
            <div class="meta">
              <span class="tag">${esc(c.meta)}</span>
              <span class="tag">Type: ${tLabel}</span>
              <span class="tag">‚ö° Cost ${c.eff.cost||0}</span>
            </div>
          </div>
        `;
      }).join("");

      errorBox.style.display="none";
      errorBox.textContent="";
    }catch(err){
      showError(err);
    }
  }

  function selectCard(idx){
    if(S.player.hp<=0 || S.enemy.hp<=0) return;
    haptic("tap");

    const pos = S.selected.indexOf(idx);
    if(pos>=0){
      S.selected.splice(pos,1);
      render();
      return;
    }

    if(wouldExceedEnergy(idx)){
      haptic("warn");
      const c=S.hand[idx];
      const costNow=selectedCost();
      const cCost=c?.eff?.cost||0;
      showPopup({
        title:"Not enough energy",
        body:`You have <b>${S.player.energy}</b> energy.<br>
              Selected cost: <b>${costNow}</b>.<br>
              <b>${esc(c?.name || "That card")}</b> costs <b>${cCost}</b>, which would exceed your energy.`,
        sub:"Unselect a card, or pick a cheaper option.",
        actionsHTML:`<button class="btn primary" onclick="hidePopup()">OK</button>`
      });
      return;
    }

    S.selected.push(idx);
    render();
  }

  function clearSelection(){
    haptic("tap");
    S.selected=[];
    render();
  }

  function newGame(){
    S={
      round:1,
      player:mech(),
      enemy:mech(),
      deck:[],
      discard:[],
      hand:[],
      selected:[],
      dampToPlayer:0,
      dampToEnemy:0,
      enemyPlanId:"MEASURED_ADVANCE",
      enemyPlanLabel:ENEMY_PLAN.MEASURED_ADVANCE
    };
    buildDeck();
    startRound();
    render();
  }

  document.getElementById("newBtn").addEventListener("click", ()=>{ haptic("ok"); newGame(); });

  document.getElementById("rulesBtn").addEventListener("click", ()=>{
    haptic("tap");
    showPopup({
      title:"Rules",
      body: `
<b>Round Flow</b><br>
Select cards (energy-limited) ‚Üí <b>Play Selected</b> ‚Üí enemy plays 2 ‚Üí press OK.<br><br>

<b>Energy</b><br>
You can select as many cards as your energy allows. Cards you can‚Äôt afford are dimmed.<br><br>

<b>Combos (apply between each pair in your chain)</b><br>
‚Ä¢ Attack‚ÜíAttack: next +2 dmg, +2 heat<br>
‚Ä¢ Defense‚ÜíAttack: next +3 dmg<br>
‚Ä¢ Utility‚ÜíAttack: next attack costs -1 energy<br>
‚Ä¢ Attack‚ÜíDefense: next defense +2 armor<br>
‚Ä¢ Utility‚ÜíDefense: next defense also -2 heat<br><br>

<b>Heat</b><br>
8+ Overheated: attacks deal ‚àí2 damage<br>
10+ Reactor critical: end-of-round ‚àí3 HP + next round ‚àí1 energy<br><br>

<b>Enemy Plan</b><br>
Shown under Enemy status. It hints at behavior, not exact cards.`,
      sub:"OK to continue.",
      actionsHTML:`<button class="btn primary" onclick="hidePopup()">OK</button>`
    });
  });

  // Expose
  window.selectCard = selectCard;
  window.clearSelection = clearSelection;
  window.playSelected = playSelected;
  window.hidePopup = hidePopup;
  window.newGame = newGame;
  window.nextRound = nextRound;
  window.nextFight = nextFight;

  // Start AFTER DOM is ready
  newGame();
})();
</script>
</body>
</html>
